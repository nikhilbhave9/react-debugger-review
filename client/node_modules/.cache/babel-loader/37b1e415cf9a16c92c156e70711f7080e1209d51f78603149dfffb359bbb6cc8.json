{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildRequestError = exports.APIResponseError = exports.UnknownHTTPResponseError = exports.isHTTPResponseError = exports.RequestTimeoutError = exports.isNotionClientError = exports.ClientErrorCode = exports.APIErrorCode = void 0;\nconst helpers_1 = require(\"./helpers\");\n/**\n * Error codes returned in responses from the API.\n */\nvar APIErrorCode;\n(function (APIErrorCode) {\n  APIErrorCode[\"Unauthorized\"] = \"unauthorized\";\n  APIErrorCode[\"RestrictedResource\"] = \"restricted_resource\";\n  APIErrorCode[\"ObjectNotFound\"] = \"object_not_found\";\n  APIErrorCode[\"RateLimited\"] = \"rate_limited\";\n  APIErrorCode[\"InvalidJSON\"] = \"invalid_json\";\n  APIErrorCode[\"InvalidRequestURL\"] = \"invalid_request_url\";\n  APIErrorCode[\"InvalidRequest\"] = \"invalid_request\";\n  APIErrorCode[\"ValidationError\"] = \"validation_error\";\n  APIErrorCode[\"ConflictError\"] = \"conflict_error\";\n  APIErrorCode[\"InternalServerError\"] = \"internal_server_error\";\n  APIErrorCode[\"ServiceUnavailable\"] = \"service_unavailable\";\n})(APIErrorCode = exports.APIErrorCode || (exports.APIErrorCode = {}));\n/**\n * Error codes generated for client errors.\n */\nvar ClientErrorCode;\n(function (ClientErrorCode) {\n  ClientErrorCode[\"RequestTimeout\"] = \"notionhq_client_request_timeout\";\n  ClientErrorCode[\"ResponseError\"] = \"notionhq_client_response_error\";\n})(ClientErrorCode = exports.ClientErrorCode || (exports.ClientErrorCode = {}));\n/**\n * Base error type.\n */\nclass NotionClientErrorBase extends Error {}\n/**\n * @param error any value, usually a caught error.\n * @returns `true` if error is a `NotionClientError`.\n */\nfunction isNotionClientError(error) {\n  return (0, helpers_1.isObject)(error) && error instanceof NotionClientErrorBase;\n}\nexports.isNotionClientError = isNotionClientError;\n/**\n * Narrows down the types of a NotionClientError.\n * @param error any value, usually a caught error.\n * @param codes an object mapping from possible error codes to `true`\n * @returns `true` if error is a `NotionClientError` with a code in `codes`.\n */\nfunction isNotionClientErrorWithCode(error, codes) {\n  return isNotionClientError(error) && error.code in codes;\n}\n/**\n * Error thrown by the client if a request times out.\n */\nclass RequestTimeoutError extends NotionClientErrorBase {\n  constructor() {\n    let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"Request to Notion API has timed out\";\n    super(message);\n    this.code = ClientErrorCode.RequestTimeout;\n    this.name = \"RequestTimeoutError\";\n  }\n  static isRequestTimeoutError(error) {\n    return isNotionClientErrorWithCode(error, {\n      [ClientErrorCode.RequestTimeout]: true\n    });\n  }\n  static rejectAfterTimeout(promise, timeoutMS) {\n    return new Promise((resolve, reject) => {\n      const timeoutId = setTimeout(() => {\n        reject(new RequestTimeoutError());\n      }, timeoutMS);\n      promise.then(resolve).catch(reject).then(() => clearTimeout(timeoutId));\n    });\n  }\n}\nexports.RequestTimeoutError = RequestTimeoutError;\nclass HTTPResponseError extends NotionClientErrorBase {\n  constructor(args) {\n    super(args.message);\n    this.name = \"HTTPResponseError\";\n    const {\n      code,\n      status,\n      headers,\n      rawBodyText\n    } = args;\n    this.code = code;\n    this.status = status;\n    this.headers = headers;\n    this.body = rawBodyText;\n  }\n}\nconst httpResponseErrorCodes = {\n  [ClientErrorCode.ResponseError]: true,\n  [APIErrorCode.Unauthorized]: true,\n  [APIErrorCode.RestrictedResource]: true,\n  [APIErrorCode.ObjectNotFound]: true,\n  [APIErrorCode.RateLimited]: true,\n  [APIErrorCode.InvalidJSON]: true,\n  [APIErrorCode.InvalidRequestURL]: true,\n  [APIErrorCode.InvalidRequest]: true,\n  [APIErrorCode.ValidationError]: true,\n  [APIErrorCode.ConflictError]: true,\n  [APIErrorCode.InternalServerError]: true,\n  [APIErrorCode.ServiceUnavailable]: true\n};\nfunction isHTTPResponseError(error) {\n  if (!isNotionClientErrorWithCode(error, httpResponseErrorCodes)) {\n    return false;\n  }\n  return true;\n}\nexports.isHTTPResponseError = isHTTPResponseError;\n/**\n * Error thrown if an API call responds with an unknown error code, or does not respond with\n * a property-formatted error.\n */\nclass UnknownHTTPResponseError extends HTTPResponseError {\n  constructor(args) {\n    var _a;\n    super({\n      ...args,\n      code: ClientErrorCode.ResponseError,\n      message: (_a = args.message) !== null && _a !== void 0 ? _a : `Request to Notion API failed with status: ${args.status}`\n    });\n    this.name = \"UnknownHTTPResponseError\";\n  }\n  static isUnknownHTTPResponseError(error) {\n    return isNotionClientErrorWithCode(error, {\n      [ClientErrorCode.ResponseError]: true\n    });\n  }\n}\nexports.UnknownHTTPResponseError = UnknownHTTPResponseError;\nconst apiErrorCodes = {\n  [APIErrorCode.Unauthorized]: true,\n  [APIErrorCode.RestrictedResource]: true,\n  [APIErrorCode.ObjectNotFound]: true,\n  [APIErrorCode.RateLimited]: true,\n  [APIErrorCode.InvalidJSON]: true,\n  [APIErrorCode.InvalidRequestURL]: true,\n  [APIErrorCode.InvalidRequest]: true,\n  [APIErrorCode.ValidationError]: true,\n  [APIErrorCode.ConflictError]: true,\n  [APIErrorCode.InternalServerError]: true,\n  [APIErrorCode.ServiceUnavailable]: true\n};\n/**\n * A response from the API indicating a problem.\n * Use the `code` property to handle various kinds of errors. All its possible values are in `APIErrorCode`.\n */\nclass APIResponseError extends HTTPResponseError {\n  constructor() {\n    super(...arguments);\n    this.name = \"APIResponseError\";\n  }\n  static isAPIResponseError(error) {\n    return isNotionClientErrorWithCode(error, apiErrorCodes);\n  }\n}\nexports.APIResponseError = APIResponseError;\nfunction buildRequestError(response, bodyText) {\n  const apiErrorResponseBody = parseAPIErrorResponseBody(bodyText);\n  if (apiErrorResponseBody !== undefined) {\n    return new APIResponseError({\n      code: apiErrorResponseBody.code,\n      message: apiErrorResponseBody.message,\n      headers: response.headers,\n      status: response.status,\n      rawBodyText: bodyText\n    });\n  }\n  return new UnknownHTTPResponseError({\n    message: undefined,\n    headers: response.headers,\n    status: response.status,\n    rawBodyText: bodyText\n  });\n}\nexports.buildRequestError = buildRequestError;\nfunction parseAPIErrorResponseBody(body) {\n  if (typeof body !== \"string\") {\n    return;\n  }\n  let parsed;\n  try {\n    parsed = JSON.parse(body);\n  } catch (parseError) {\n    return;\n  }\n  if (!(0, helpers_1.isObject)(parsed) || typeof parsed[\"message\"] !== \"string\" || !isAPIErrorCode(parsed[\"code\"])) {\n    return;\n  }\n  return {\n    ...parsed,\n    code: parsed[\"code\"],\n    message: parsed[\"message\"]\n  };\n}\nfunction isAPIErrorCode(code) {\n  return typeof code === \"string\" && code in apiErrorCodes;\n}","map":{"version":3,"mappings":";;;;;;AACA;AAGA;;;AAGA,IAAYA,YAYX;AAZD,WAAYA,YAAY;EACtBA,6CAA6B;EAC7BA,0DAA0C;EAC1CA,mDAAmC;EACnCA,4CAA4B;EAC5BA,4CAA4B;EAC5BA,yDAAyC;EACzCA,kDAAkC;EAClCA,oDAAoC;EACpCA,gDAAgC;EAChCA,6DAA6C;EAC7CA,0DAA0C;AAC5C,CAAC,EAZWA,YAAY,GAAZC,oBAAY,KAAZA,oBAAY;AAcxB;;;AAGA,IAAYC,eAGX;AAHD,WAAYA,eAAe;EACzBA,qEAAkD;EAClDA,mEAAgD;AAClD,CAAC,EAHWA,eAAe,GAAfD,uBAAe,KAAfA,uBAAe;AAU3B;;;AAGA,MAAeE,qBAEb,SAAQC,KAAK;AAuBf;;;;AAIA,SAAgBC,mBAAmB,CACjCC,KAAc;EAEd,OAAO,sBAAQ,EAACA,KAAK,CAAC,IAAIA,KAAK,YAAYH,qBAAqB;AAClE;AAJAF;AAMA;;;;;;AAMA,SAASM,2BAA2B,CAClCD,KAAc,EACdE,KAA4B;EAE5B,OAAOH,mBAAmB,CAACC,KAAK,CAAC,IAAIA,KAAK,CAACG,IAAI,IAAID,KAAK;AAC1D;AAEA;;;AAGA,MAAaE,mBAAoB,SAAQP,qBAAqD;EAI5FQ,cAA2D;IAAA,IAA/CC,OAAO,uEAAG,qCAAqC;IACzD,KAAK,CAACA,OAAO,CAAC;IAJP,SAAI,GAAGV,eAAe,CAACW,cAAc;IACrC,SAAI,GAAG,qBAAqB;EAIrC;EAEA,OAAOC,qBAAqB,CAACR,KAAc;IACzC,OAAOC,2BAA2B,CAACD,KAAK,EAAE;MACxC,CAACJ,eAAe,CAACW,cAAc,GAAG;KACnC,CAAC;EACJ;EAEA,OAAOE,kBAAkB,CACvBC,OAAmB,EACnBC,SAAiB;IAEjB,OAAO,IAAIC,OAAO,CAAI,CAACC,OAAO,EAAEC,MAAM,KAAI;MACxC,MAAMC,SAAS,GAAGC,UAAU,CAAC,MAAK;QAChCF,MAAM,CAAC,IAAIV,mBAAmB,EAAE,CAAC;MACnC,CAAC,EAAEO,SAAS,CAAC;MAEbD,OAAO,CACJO,IAAI,CAACJ,OAAO,CAAC,CACbK,KAAK,CAACJ,MAAM,CAAC,CACbG,IAAI,CAAC,MAAME,YAAY,CAACJ,SAAS,CAAC,CAAC;IACxC,CAAC,CAAC;EACJ;;AA5BFpB;AAiCA,MAAMyB,iBAEJ,SAAQvB,qBAA2B;EAOnCQ,YAAYgB,IAMX;IACC,KAAK,CAACA,IAAI,CAACf,OAAO,CAAC;IAbZ,SAAI,GAAW,mBAAmB;IAczC,MAAM;MAAEH,IAAI;MAAEmB,MAAM;MAAEC,OAAO;MAAEC;IAAW,CAAE,GAAGH,IAAI;IACnD,IAAI,CAAClB,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACmB,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACC,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACE,IAAI,GAAGD,WAAW;EACzB;;AAGF,MAAME,sBAAsB,GAA2C;EACrE,CAAC9B,eAAe,CAAC+B,aAAa,GAAG,IAAI;EACrC,CAACjC,YAAY,CAACkC,YAAY,GAAG,IAAI;EACjC,CAAClC,YAAY,CAACmC,kBAAkB,GAAG,IAAI;EACvC,CAACnC,YAAY,CAACoC,cAAc,GAAG,IAAI;EACnC,CAACpC,YAAY,CAACqC,WAAW,GAAG,IAAI;EAChC,CAACrC,YAAY,CAACsC,WAAW,GAAG,IAAI;EAChC,CAACtC,YAAY,CAACuC,iBAAiB,GAAG,IAAI;EACtC,CAACvC,YAAY,CAACwC,cAAc,GAAG,IAAI;EACnC,CAACxC,YAAY,CAACyC,eAAe,GAAG,IAAI;EACpC,CAACzC,YAAY,CAAC0C,aAAa,GAAG,IAAI;EAClC,CAAC1C,YAAY,CAAC2C,mBAAmB,GAAG,IAAI;EACxC,CAAC3C,YAAY,CAAC4C,kBAAkB,GAAG;CACpC;AAED,SAAgBC,mBAAmB,CACjCvC,KAAc;EAEd,IAAI,CAACC,2BAA2B,CAACD,KAAK,EAAE0B,sBAAsB,CAAC,EAAE;IAC/D,OAAO,KAAK;;EAQd,OAAO,IAAI;AACb;AAbA/B;AAeA;;;;AAIA,MAAa6C,wBAAyB,SAAQpB,iBAAgD;EAG5Ff,YAAYgB,IAKX;;IACC,KAAK,CAAC;MACJ,GAAGA,IAAI;MACPlB,IAAI,EAAEP,eAAe,CAAC+B,aAAa;MACnCrB,OAAO,EACL,UAAI,CAACA,OAAO,mCACZ,6CAA6Ce,IAAI,CAACC,MAAM;KAC3D,CAAC;IAdK,SAAI,GAAG,0BAA0B;EAe1C;EAEA,OAAOmB,0BAA0B,CAC/BzC,KAAc;IAEd,OAAOC,2BAA2B,CAACD,KAAK,EAAE;MACxC,CAACJ,eAAe,CAAC+B,aAAa,GAAG;KAClC,CAAC;EACJ;;AAxBFhC;AA2BA,MAAM+C,aAAa,GAAkC;EACnD,CAAChD,YAAY,CAACkC,YAAY,GAAG,IAAI;EACjC,CAAClC,YAAY,CAACmC,kBAAkB,GAAG,IAAI;EACvC,CAACnC,YAAY,CAACoC,cAAc,GAAG,IAAI;EACnC,CAACpC,YAAY,CAACqC,WAAW,GAAG,IAAI;EAChC,CAACrC,YAAY,CAACsC,WAAW,GAAG,IAAI;EAChC,CAACtC,YAAY,CAACuC,iBAAiB,GAAG,IAAI;EACtC,CAACvC,YAAY,CAACwC,cAAc,GAAG,IAAI;EACnC,CAACxC,YAAY,CAACyC,eAAe,GAAG,IAAI;EACpC,CAACzC,YAAY,CAAC0C,aAAa,GAAG,IAAI;EAClC,CAAC1C,YAAY,CAAC2C,mBAAmB,GAAG,IAAI;EACxC,CAAC3C,YAAY,CAAC4C,kBAAkB,GAAG;CACpC;AAED;;;;AAIA,MAAaK,gBAAiB,SAAQvB,iBAA+B;EAArEf;;IACW,SAAI,GAAG,kBAAkB;EAKpC;EAHE,OAAOuC,kBAAkB,CAAC5C,KAAc;IACtC,OAAOC,2BAA2B,CAACD,KAAK,EAAE0C,aAAa,CAAC;EAC1D;;AALF/C;AAQA,SAAgBkD,iBAAiB,CAC/BC,QAA2B,EAC3BC,QAAgB;EAEhB,MAAMC,oBAAoB,GAAGC,yBAAyB,CAACF,QAAQ,CAAC;EAChE,IAAIC,oBAAoB,KAAKE,SAAS,EAAE;IACtC,OAAO,IAAIP,gBAAgB,CAAC;MAC1BxC,IAAI,EAAE6C,oBAAoB,CAAC7C,IAAI;MAC/BG,OAAO,EAAE0C,oBAAoB,CAAC1C,OAAO;MACrCiB,OAAO,EAAEuB,QAAQ,CAACvB,OAAO;MACzBD,MAAM,EAAEwB,QAAQ,CAACxB,MAAM;MACvBE,WAAW,EAAEuB;KACd,CAAC;;EAEJ,OAAO,IAAIP,wBAAwB,CAAC;IAClClC,OAAO,EAAE4C,SAAS;IAClB3B,OAAO,EAAEuB,QAAQ,CAACvB,OAAO;IACzBD,MAAM,EAAEwB,QAAQ,CAACxB,MAAM;IACvBE,WAAW,EAAEuB;GACd,CAAC;AACJ;AApBApD;AAsBA,SAASsD,yBAAyB,CAChCxB,IAAY;EAEZ,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;IAC5B;;EAGF,IAAI0B,MAAe;EACnB,IAAI;IACFA,MAAM,GAAGC,IAAI,CAACC,KAAK,CAAC5B,IAAI,CAAC;GAC1B,CAAC,OAAO6B,UAAU,EAAE;IACnB;;EAGF,IACE,CAAC,sBAAQ,EAACH,MAAM,CAAC,IACjB,OAAOA,MAAM,CAAC,SAAS,CAAC,KAAK,QAAQ,IACrC,CAACI,cAAc,CAACJ,MAAM,CAAC,MAAM,CAAC,CAAC,EAC/B;IACA;;EAGF,OAAO;IACL,GAAGA,MAAM;IACThD,IAAI,EAAEgD,MAAM,CAAC,MAAM,CAAC;IACpB7C,OAAO,EAAE6C,MAAM,CAAC,SAAS;GAC1B;AACH;AAEA,SAASI,cAAc,CAACpD,IAAa;EACnC,OAAO,OAAOA,IAAI,KAAK,QAAQ,IAAIA,IAAI,IAAIuC,aAAa;AAC1D","names":["APIErrorCode","exports","ClientErrorCode","NotionClientErrorBase","Error","isNotionClientError","error","isNotionClientErrorWithCode","codes","code","RequestTimeoutError","constructor","message","RequestTimeout","isRequestTimeoutError","rejectAfterTimeout","promise","timeoutMS","Promise","resolve","reject","timeoutId","setTimeout","then","catch","clearTimeout","HTTPResponseError","args","status","headers","rawBodyText","body","httpResponseErrorCodes","ResponseError","Unauthorized","RestrictedResource","ObjectNotFound","RateLimited","InvalidJSON","InvalidRequestURL","InvalidRequest","ValidationError","ConflictError","InternalServerError","ServiceUnavailable","isHTTPResponseError","UnknownHTTPResponseError","isUnknownHTTPResponseError","apiErrorCodes","APIResponseError","isAPIResponseError","buildRequestError","response","bodyText","apiErrorResponseBody","parseAPIErrorResponseBody","undefined","parsed","JSON","parse","parseError","isAPIErrorCode"],"sources":["/home/nikhilbhave9/reactdevtools/web-bug-log/node_modules/@notionhq/client/src/errors.ts"],"sourcesContent":["import { SupportedResponse } from \"./fetch-types\"\nimport { isObject } from \"./helpers\"\nimport { Assert } from \"./type-utils\"\n\n/**\n * Error codes returned in responses from the API.\n */\nexport enum APIErrorCode {\n  Unauthorized = \"unauthorized\",\n  RestrictedResource = \"restricted_resource\",\n  ObjectNotFound = \"object_not_found\",\n  RateLimited = \"rate_limited\",\n  InvalidJSON = \"invalid_json\",\n  InvalidRequestURL = \"invalid_request_url\",\n  InvalidRequest = \"invalid_request\",\n  ValidationError = \"validation_error\",\n  ConflictError = \"conflict_error\",\n  InternalServerError = \"internal_server_error\",\n  ServiceUnavailable = \"service_unavailable\",\n}\n\n/**\n * Error codes generated for client errors.\n */\nexport enum ClientErrorCode {\n  RequestTimeout = \"notionhq_client_request_timeout\",\n  ResponseError = \"notionhq_client_response_error\",\n}\n\n/**\n * Error codes on errors thrown by the `Client`.\n */\nexport type NotionErrorCode = APIErrorCode | ClientErrorCode\n\n/**\n * Base error type.\n */\nabstract class NotionClientErrorBase<\n  Code extends NotionErrorCode\n> extends Error {\n  abstract code: Code\n}\n\n/**\n * Error type that encompasses all the kinds of errors that the Notion client will throw.\n */\nexport type NotionClientError =\n  | RequestTimeoutError\n  | UnknownHTTPResponseError\n  | APIResponseError\n\n// Assert that NotionClientError's `code` property is a narrow type.\n// This prevents us from accidentally regressing to `string`-typed name field.\ntype _assertCodeIsNarrow = Assert<NotionErrorCode, NotionClientError[\"code\"]>\n\n// Assert that the type of `name` in NotionErrorCode is a narrow type.\n// This prevents us from accidentally regressing to `string`-typed name field.\ntype _assertNameIsNarrow = Assert<\n  \"RequestTimeoutError\" | \"UnknownHTTPResponseError\" | \"APIResponseError\",\n  NotionClientError[\"name\"]\n>\n\n/**\n * @param error any value, usually a caught error.\n * @returns `true` if error is a `NotionClientError`.\n */\nexport function isNotionClientError(\n  error: unknown\n): error is NotionClientError {\n  return isObject(error) && error instanceof NotionClientErrorBase\n}\n\n/**\n * Narrows down the types of a NotionClientError.\n * @param error any value, usually a caught error.\n * @param codes an object mapping from possible error codes to `true`\n * @returns `true` if error is a `NotionClientError` with a code in `codes`.\n */\nfunction isNotionClientErrorWithCode<Code extends NotionErrorCode>(\n  error: unknown,\n  codes: { [C in Code]: true }\n): error is NotionClientError & { code: Code } {\n  return isNotionClientError(error) && error.code in codes\n}\n\n/**\n * Error thrown by the client if a request times out.\n */\nexport class RequestTimeoutError extends NotionClientErrorBase<ClientErrorCode.RequestTimeout> {\n  readonly code = ClientErrorCode.RequestTimeout\n  readonly name = \"RequestTimeoutError\"\n\n  constructor(message = \"Request to Notion API has timed out\") {\n    super(message)\n  }\n\n  static isRequestTimeoutError(error: unknown): error is RequestTimeoutError {\n    return isNotionClientErrorWithCode(error, {\n      [ClientErrorCode.RequestTimeout]: true,\n    })\n  }\n\n  static rejectAfterTimeout<T>(\n    promise: Promise<T>,\n    timeoutMS: number\n  ): Promise<T> {\n    return new Promise<T>((resolve, reject) => {\n      const timeoutId = setTimeout(() => {\n        reject(new RequestTimeoutError())\n      }, timeoutMS)\n\n      promise\n        .then(resolve)\n        .catch(reject)\n        .then(() => clearTimeout(timeoutId))\n    })\n  }\n}\n\ntype HTTPResponseErrorCode = ClientErrorCode.ResponseError | APIErrorCode\n\nclass HTTPResponseError<\n  Code extends HTTPResponseErrorCode\n> extends NotionClientErrorBase<Code> {\n  readonly name: string = \"HTTPResponseError\"\n  readonly code: Code\n  readonly status: number\n  readonly headers: SupportedResponse[\"headers\"]\n  readonly body: string\n\n  constructor(args: {\n    code: Code\n    status: number\n    message: string\n    headers: SupportedResponse[\"headers\"]\n    rawBodyText: string\n  }) {\n    super(args.message)\n    const { code, status, headers, rawBodyText } = args\n    this.code = code\n    this.status = status\n    this.headers = headers\n    this.body = rawBodyText\n  }\n}\n\nconst httpResponseErrorCodes: { [C in HTTPResponseErrorCode]: true } = {\n  [ClientErrorCode.ResponseError]: true,\n  [APIErrorCode.Unauthorized]: true,\n  [APIErrorCode.RestrictedResource]: true,\n  [APIErrorCode.ObjectNotFound]: true,\n  [APIErrorCode.RateLimited]: true,\n  [APIErrorCode.InvalidJSON]: true,\n  [APIErrorCode.InvalidRequestURL]: true,\n  [APIErrorCode.InvalidRequest]: true,\n  [APIErrorCode.ValidationError]: true,\n  [APIErrorCode.ConflictError]: true,\n  [APIErrorCode.InternalServerError]: true,\n  [APIErrorCode.ServiceUnavailable]: true,\n}\n\nexport function isHTTPResponseError(\n  error: unknown\n): error is UnknownHTTPResponseError | APIResponseError {\n  if (!isNotionClientErrorWithCode(error, httpResponseErrorCodes)) {\n    return false\n  }\n\n  type _assert = Assert<\n    UnknownHTTPResponseError | APIResponseError,\n    typeof error\n  >\n\n  return true\n}\n\n/**\n * Error thrown if an API call responds with an unknown error code, or does not respond with\n * a property-formatted error.\n */\nexport class UnknownHTTPResponseError extends HTTPResponseError<ClientErrorCode.ResponseError> {\n  readonly name = \"UnknownHTTPResponseError\"\n\n  constructor(args: {\n    status: number\n    message: string | undefined\n    headers: SupportedResponse[\"headers\"]\n    rawBodyText: string\n  }) {\n    super({\n      ...args,\n      code: ClientErrorCode.ResponseError,\n      message:\n        args.message ??\n        `Request to Notion API failed with status: ${args.status}`,\n    })\n  }\n\n  static isUnknownHTTPResponseError(\n    error: unknown\n  ): error is UnknownHTTPResponseError {\n    return isNotionClientErrorWithCode(error, {\n      [ClientErrorCode.ResponseError]: true,\n    })\n  }\n}\n\nconst apiErrorCodes: { [C in APIErrorCode]: true } = {\n  [APIErrorCode.Unauthorized]: true,\n  [APIErrorCode.RestrictedResource]: true,\n  [APIErrorCode.ObjectNotFound]: true,\n  [APIErrorCode.RateLimited]: true,\n  [APIErrorCode.InvalidJSON]: true,\n  [APIErrorCode.InvalidRequestURL]: true,\n  [APIErrorCode.InvalidRequest]: true,\n  [APIErrorCode.ValidationError]: true,\n  [APIErrorCode.ConflictError]: true,\n  [APIErrorCode.InternalServerError]: true,\n  [APIErrorCode.ServiceUnavailable]: true,\n}\n\n/**\n * A response from the API indicating a problem.\n * Use the `code` property to handle various kinds of errors. All its possible values are in `APIErrorCode`.\n */\nexport class APIResponseError extends HTTPResponseError<APIErrorCode> {\n  readonly name = \"APIResponseError\"\n\n  static isAPIResponseError(error: unknown): error is APIResponseError {\n    return isNotionClientErrorWithCode(error, apiErrorCodes)\n  }\n}\n\nexport function buildRequestError(\n  response: SupportedResponse,\n  bodyText: string\n): APIResponseError | UnknownHTTPResponseError {\n  const apiErrorResponseBody = parseAPIErrorResponseBody(bodyText)\n  if (apiErrorResponseBody !== undefined) {\n    return new APIResponseError({\n      code: apiErrorResponseBody.code,\n      message: apiErrorResponseBody.message,\n      headers: response.headers,\n      status: response.status,\n      rawBodyText: bodyText,\n    })\n  }\n  return new UnknownHTTPResponseError({\n    message: undefined,\n    headers: response.headers,\n    status: response.status,\n    rawBodyText: bodyText,\n  })\n}\n\nfunction parseAPIErrorResponseBody(\n  body: string\n): { code: APIErrorCode; message: string } | undefined {\n  if (typeof body !== \"string\") {\n    return\n  }\n\n  let parsed: unknown\n  try {\n    parsed = JSON.parse(body)\n  } catch (parseError) {\n    return\n  }\n\n  if (\n    !isObject(parsed) ||\n    typeof parsed[\"message\"] !== \"string\" ||\n    !isAPIErrorCode(parsed[\"code\"])\n  ) {\n    return\n  }\n\n  return {\n    ...parsed,\n    code: parsed[\"code\"],\n    message: parsed[\"message\"],\n  }\n}\n\nfunction isAPIErrorCode(code: unknown): code is APIErrorCode {\n  return typeof code === \"string\" && code in apiErrorCodes\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}